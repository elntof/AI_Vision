import os
import sys
import time
import re
import csv
from datetime import datetime
from pathlib import Path
from collections import deque
import numpy as np
import cv2
import torch
import timm
from PIL import Image
from torchvision import transforms as T
from PySide6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QSpinBox,
    QGroupBox, QSizePolicy, QLineEdit, QLayout, QCheckBox)
from PySide6.QtCore import Qt, QTimer, QSettings, QThread, QObject, Signal, Slot, QDateTime, QRect
from PySide6.QtGui import QPixmap, QImage, QPainter, QColor, QPen, QGuiApplication, QFont
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

# 환경 플래그: 경로 및 저장동작 테스트(True) / 운영(False) 모드 구분
LOAD_TEST_MODE = True
SAVE_TEST_MODE = True
INI_TEST_MODE = True

# 실행파일 실행 시, "자동 시작 동작 수행" 여부 플래그 : 자동 시작(True) / 수동 시작(False)
AUTO_START_ON_LAUNCH = False

# 이미지/CSV/INI 경로 설정
if LOAD_TEST_MODE:
    IMG_INPUT_DIR = Path('./Images')
else:
    IMG_INPUT_DIR = Path(r'D:/AI Vision/Images')

if SAVE_TEST_MODE:
    CSV_OUTPUT_DIR = Path('./icing_info')
else:
    CSV_OUTPUT_DIR = Path(r'D:/AI Vision/icing_info')

LOT_DETAILS_DIR = CSV_OUTPUT_DIR / "lot details"

if INI_TEST_MODE:
    try:
        ini_base_dir = Path(os.path.dirname(os.path.abspath(__file__)))
    except Exception:
        ini_base_dir = Path(os.getcwd())
    INI_SETTINGS_PATH = ini_base_dir / "IcingClassificationApp.ini"
else:
    INI_SETTINGS_PATH = Path(r'D:/AI Vision/IcingClassificationApp.ini')

# 출력 경로 생성
os.makedirs(CSV_OUTPUT_DIR, exist_ok=True)
os.makedirs(LOT_DETAILS_DIR, exist_ok=True)

# 메인 윈도우 기본 위치 (모니터 좌측 하단 기준 offset)
WINDOW_OFFSET_X = 100
WINDOW_OFFSET_Y = 200

# 신규 이미지 부재 시 미리보기 플레이스홀더 텍스트
NO_IMAGE_PLACEHOLDER_TEXT = "신규 이미지 없음"
DISALLOWED_PLACEHOLDER_TEXT = "허용 공정이 아님"

# 감시 대상 이미지 확장자 목록
ALLOWED_IMAGE_EXTS = {'.jpg', '.jpeg', '.png', '.bmp', '.tif', '.tiff'}

# 분류/ 판정 허용 공정
ALLOWED_PULLER_MODES = {"BEFOFEED"}

# ViT 분류 파라미터
MODEL_NAME = "vit_small_patch16_224"
CLASS_NAMES = ["Melted", "Icing", "Iced"]

def resource_path(rel_path: str) -> Path:
    """PyInstaller(onefile) 포함 리소스 경로 헬퍼"""
    base_dir = getattr(sys, "_MEIPASS", None)
    if base_dir:
        return Path(base_dir) / rel_path
    return Path(__file__).resolve().parent / rel_path

CHECKPOINT_PATH = resource_path("vit_melted_icing_iced_best_ema.pth")
IMG_SIZE = 224

# ROI 기본값
DEFAULT_ROI_RECT = (40, 0, 200, 555)

# 그래프 패널 크기
PANEL_W_PX, PANEL_H_PX = 405, 270

def clamp_roi_to_shape(roi: tuple[int, int, int, int] | None, width: int, height: int):
    """이미지 크기에 맞춰 ROI를 보정"""
    if roi is None:
        return None
    if width <= 0 or height <= 0:
        return None
    x, y, w, h = map(int, roi)
    x = max(0, min(x, width - 1))
    y = max(0, min(y, height - 1))
    w = max(1, min(w, width - x))
    h = max(1, min(h, height - y))
    return x, y, w, h

def safe_image_load(image_path, as_gray=False, max_retries=5, delay=0.2):
    """안전 이미지 로딩 (재시도 최대 5회)"""
    flag = cv2.IMREAD_GRAYSCALE if as_gray else cv2.IMREAD_UNCHANGED
    for _ in range(max_retries):
        try:
            img_array = np.fromfile(str(image_path), dtype=np.uint8)
            img = cv2.imdecode(img_array, flag)
            if img is not None:
                return img
        except Exception:
            pass
        time.sleep(delay)
    return None

def _numpy_to_qimage(npimg) -> QImage:
    """NumPy 이미지를 QImage로 변환 (채널 수에 따라 자동 변환)"""
    if npimg is None:
        return QImage()

    if npimg.ndim == 2:
        h, w = npimg.shape
        return QImage(npimg.data, w, h, w, QImage.Format_Grayscale8).copy()

    if npimg.shape[2] == 3:
        rgb = cv2.cvtColor(npimg, cv2.COLOR_BGR2RGB)
        h, w, _ = rgb.shape
        return QImage(rgb.data, w, h, 3 * w, QImage.Format_RGB888).copy()

    if npimg.shape[2] == 4:
        rgba = cv2.cvtColor(npimg, cv2.COLOR_BGRA2RGBA)
        h, w, _ = rgba.shape
        return QImage(rgba.data, w, h, 4 * w, QImage.Format_RGBA8888).copy()

    gray = cv2.cvtColor(npimg, cv2.COLOR_BGR2GRAY)
    h, w = gray.shape
    return QImage(gray.data, w, h, w, QImage.Format_Grayscale8).copy()

def pixmap_from_numpy(npimg, target_size: tuple[int, int] | None = None) -> QPixmap:
    """NumPy 이미지를 QPixmap으로 변환 후 필요 시 스케일링"""
    qimg = _numpy_to_qimage(npimg)
    if qimg.isNull():
        return QPixmap()
    pm = QPixmap.fromImage(qimg)
    if target_size:
        pm = pm.scaled(*target_size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
    return pm

def parse_filename(fname: str):
    """파일명 파서 (형식: EQUIP_Lot#_Process_Attempt_YYYYMMDD_HHMM(SS).ext)"""
    stem = Path(fname).stem
    parts = stem.split('_')
    try:
        equip = parts[0]
        lot = parts[1]
        process = parts[2]
        attempt = int(parts[3])
        date_str = parts[4]
        time_str = parts[5]
    except Exception:
        equip = lot = process = date_str = time_str = ''
        attempt = 0
    return {'equip': equip, 'lot': lot, 'process': process, 'attempt': attempt, 'date': date_str, 'time': time_str, 'stem': stem, 'name': Path(fname).name}

def extract_image_datetime(path: Path) -> QDateTime:
    """파일명으로부터 QDateTime 추출 (YYMMDD_HHMMSS 형식 지원, 실패 시 mtime 사용)"""
    stem = path.stem

    info = parse_filename(path.name)
    date_str = info.get('date') or ''
    time_str = info.get('time') or ''

    try:
        if len(date_str) == 6 and len(time_str) >= 4:
            yy = int(date_str[0:2])
            mm = int(date_str[2:4])
            dd = int(date_str[4:6])
            yyyy = 2000 + yy

            hh = int(time_str[0:2])
            mi = int(time_str[2:4])
            ss = int(time_str[4:6]) if len(time_str) >= 6 else 0

            qdt = QDateTime(yyyy, mm, dd, hh, mi, ss)
            if qdt.isValid():
                return qdt
    except Exception:
        pass

    m = re.search(r'(\d{6})[_-]?(\d{4,6})', stem)
    if m:
        try:
            date_part = m.group(1)
            time_part = m.group(2)

            yy = int(date_part[0:2])
            mm = int(date_part[2:4])
            dd = int(date_part[4:6])
            yyyy = 2000 + yy

            hh = int(time_part[0:2])
            mi = int(time_part[2:4])
            ss = int(time_part[4:6]) if len(time_part) >= 6 else 0

            qdt = QDateTime(yyyy, mm, dd, hh, mi, ss)
            if qdt.isValid():
                return qdt
        except Exception:
            pass

    try:
        ts = path.stat().st_mtime
        return QDateTime.fromSecsSinceEpoch(int(ts))
    except Exception:
        return QDateTime()

def _qdatetime_to_datetime(qdt: QDateTime | None):
    """QDateTime → datetime 변환"""
    if qdt is None or not isinstance(qdt, QDateTime) or not qdt.isValid():
        return None
    if hasattr(qdt, "toPython"):
        try:
            return qdt.toPython()
        except Exception:
            pass
    try:
        return datetime.fromtimestamp(qdt.toSecsSinceEpoch())
    except Exception:
        return None

def _safe_float(value, default: float = 0.0) -> float:
    """float 변환 실패 시 기본값 반환"""
    try:
        return float(value)
    except Exception:
        return default

def _csv_get(row: list, idx_map: dict, name: str, default: str = "") -> str:
    """CSV row에서 컬럼명 기반 안전 조회"""
    idx = idx_map.get(name)
    if idx is None or idx >= len(row):
        return default
    return row[idx]

def format_mmdd_hhmm(qdt: QDateTime | None) -> str:
    """MM/DD HH:mm 포맷 문자열"""
    if qdt is None or not isinstance(qdt, QDateTime) or not qdt.isValid():
        return ""
    return qdt.toString("MM/dd HH:mm")

def compute_lead_minutes(start_a: QDateTime | None, start_b: QDateTime | None) -> str:
    """두 시각 차이를 분 단위로 계산"""
    dt_start = _qdatetime_to_datetime(start_a)
    dt_end = _qdatetime_to_datetime(start_b)
    if dt_start is None or dt_end is None or dt_end < dt_start:
        return ""
    minutes = (dt_end - dt_start).total_seconds() / 60.0
    return f"{minutes:.1f}"

class ViTClassifier:
    """학습된 ViT 모델을 사용한 3 클래스 분류기"""

    def __init__(self, model_name: str, checkpoint: Path, class_names: list[str], img_size: int = 224):
        self.model_name = model_name
        self.class_names = list(class_names)
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.model = timm.create_model(model_name, pretrained=False, num_classes=len(self.class_names))

        if checkpoint.exists():
            try:
                state = torch.load(checkpoint, map_location="cpu")
                if isinstance(state, dict) and "state_dict" in state:
                    state = state["state_dict"]
                cleaned = {k.replace("model.", "").replace("module.", ""): v for k, v in state.items()}
                self.model.load_state_dict(cleaned, strict=False)
            except Exception as e:
                print(f"모델 가중치 로드 실패: {e}")
        else:
            print(f"체크포인트가 존재하지 않습니다: {checkpoint}")

        self.model.to(self.device)
        self.model.eval()

        self.transform_gray = T.Compose([
            T.Resize((img_size, img_size)),
            T.ToTensor(),
            T.Lambda(lambda t: t.expand(3, -1, -1)),
            T.Normalize(mean=[0.485, 0.456, 0.406],
                        std=[0.229, 0.224, 0.225]),
        ])

    @staticmethod
    def _crop_with_roi(img_np: np.ndarray, roi: tuple[int, int, int, int] | None):
        if img_np is None or roi is None:
            return img_np
        h, w = img_np.shape[:2]
        clamped = clamp_roi_to_shape(roi, w, h)
        if clamped is None:
            return img_np
        x, y, rw, rh = clamped
        return img_np[y:y+rh, x:x+rw]

    def predict(self, image_path: Path, roi: tuple[int, int, int, int] | None = None, return_gray_for_preview: bool = False):
        """이미지 경로를 입력받아 (라벨, 확률) or (라벨, 확률, 그레이원본) 반환"""
        try:
            img_gray = safe_image_load(str(image_path), as_gray=True, max_retries=5, delay=0.2)
            if img_gray is None:
                raise OSError(f"이미지 로드 실패: {image_path}")

            img_crop = self._crop_with_roi(img_gray, roi)
            pil_img = Image.fromarray(img_crop)
            if pil_img.mode != "L":
                pil_img = pil_img.convert("L")

            tensor = self.transform_gray(pil_img).unsqueeze(0).to(self.device)

            with torch.no_grad():
                logits = self.model(tensor)
                raw_probs = torch.softmax(logits, dim=1).squeeze(0).cpu().numpy()

            if raw_probs.shape[0] == 3:
                probs = np.array([raw_probs[2], raw_probs[1], raw_probs[0]], dtype=np.float32)
            else:
                probs = raw_probs.astype(np.float32)

            idx = int(np.argmax(probs))
            label = self.class_names[idx]

            if return_gray_for_preview:
                return label, probs, img_gray
            return label, probs

        except Exception as e:
            print(f"❌ 분류 실패: {e}")
            if return_gray_for_preview:
                return None, None, None
            return None, None

class _ImageFileEventHandler(FileSystemEventHandler):
    """watchdog 이벤트 핸들러 (신규 이미지 감지)"""

    def __init__(self, callback, allow_ext):
        super().__init__()
        self._callback = callback
        self._allow_ext = tuple(allow_ext)

    def _handle_path(self, src_path):
        if not src_path:
            return
        path = Path(src_path)
        if path.is_dir():
            return
        if path.suffix.lower() not in self._allow_ext:
            return
        self._callback(path)

    def on_created(self, event):
        self._handle_path(getattr(event, 'src_path', None))

    def on_moved(self, event):
        self._handle_path(getattr(event, 'dest_path', None))

class ImageDirectoryWatcher(QObject):
    """watchdog 기반 이미지 디렉토리 감시기"""

    file_created = Signal(object)

    def __init__(self, directory: Path, allow_ext=None, parent=None):
        super().__init__(parent)
        self._directory = Path(directory)
        self._observer: Observer | None = None  # pyright: ignore[reportInvalidTypeForm]
        self._handler: _ImageFileEventHandler | None = None
        if allow_ext is None:
            allow_ext = ALLOWED_IMAGE_EXTS
        self._allow_ext = {ext.lower() for ext in allow_ext}

    def start(self):
        if self._observer is not None:
            return
        if not self._directory.exists():
            self._directory.mkdir(parents=True, exist_ok=True)
        self._handler = _ImageFileEventHandler(self.file_created.emit, self._allow_ext)
        observer = Observer()
        observer.schedule(self._handler, str(self._directory), recursive=False)
        observer.start()
        self._observer = observer

    def stop(self):
        if self._observer is None:
            return
        observer = self._observer
        self._observer = None
        self._handler = None
        try:
            observer.stop()
            observer.join(timeout=2.0)
        except Exception:
            pass

    def is_running(self) -> bool:
        return self._observer is not None

class ImagePreviewLabel(QLabel):
    """이미지 미리보기 (원본 + ROI 박스)"""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.pixmap = None
        self.src_shape = None
        self.roi_rect: tuple[int, int, int, int] | None = None
        self.setAlignment(Qt.AlignCenter)
        self.setFixedSize(170, 360)
        self.filename = ''
        self.placeholder_text = ""
        self.placeholder_font_pt = 11

    def show_placeholder(self, text: str):
        self.pixmap = None
        self.src_shape = None
        self.roi_rect = None
        self.placeholder_text = text or ""
        self.filename = ''
        self.update()

    def show_image(self, npimg, filename: str = '', roi: tuple[int, int, int, int] | None = None):
        self.placeholder_text = ""
        self.src_shape = npimg.shape if npimg is not None else None
        self.pixmap = pixmap_from_numpy(npimg, target_size=(self.width(), self.height()))
        self.filename = filename
        if self.src_shape is not None:
            self.roi_rect = clamp_roi_to_shape(roi, self.src_shape[1], self.src_shape[0])
        else:
            self.roi_rect = None
        self.update()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.fillRect(self.rect(), QColor('black'))
        if self.pixmap is not None and not self.pixmap.isNull():
            pm = self.pixmap
            x = (self.width() - pm.width()) // 2
            y = (self.height() - pm.height()) // 2
            painter.drawPixmap(x, y, pm)
            if self.roi_rect and self.src_shape:
                src_h, src_w = self.src_shape[0], self.src_shape[1]
                if src_w > 0 and src_h > 0:
                    scale_x = pm.width() / src_w
                    scale_y = pm.height() / src_h
                    r_x, r_y, r_w, r_h = self.roi_rect
                    draw_x = x + int(r_x * scale_x)
                    draw_y = y + int(r_y * scale_y)
                    draw_w = int(r_w * scale_x)
                    draw_h = int(r_h * scale_y)
                    painter.setPen(QPen(QColor('lime'), 1))
                    painter.drawRect(draw_x, draw_y, draw_w, draw_h)
        else:
            painter.setPen(QPen(Qt.white))
            f = painter.font()
            f.setPointSize(self.placeholder_font_pt)
            painter.setFont(f)
            painter.drawText(self.rect(), Qt.AlignCenter, self.placeholder_text)

        painter.end()

class ClassificationPanel(QWidget):
    """3박스 판정 확률 + 리드타임/파일명 텍스트 패널"""

    # ---- 레이아웃/스타일 상수 ----
    OUTER_MARGIN = 15             # 패널 좌우/하단 여백
    HEADER_EXTRA_TOP = 12         # 상단 여백 보정 (파일명 영역 위쪽)
    HEADER_LINE_HEIGHT = 20       # 파일명/리드타임 텍스트 줄 간격

    BOX_GAP = 10                  # 박스 사이 가로 간격
    BOX_TITLE_GAP = 23            # 박스 위 타이틀과 박스 사이 간격
    BOX_TOP_EXTRA = 20            # 헤더 영역 아래에서 박스 시작까지 여분
    BOX_MIN_SIDE = 20             # 박스 한 변의 최소 픽셀

    PANEL_BOTTOM_MARGIN = 2       # 패널 하단 여유(박스 영역 기준)
    # ---------------------------

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedSize(PANEL_W_PX, PANEL_H_PX)
        self.setMinimumSize(PANEL_W_PX, PANEL_H_PX)
        self.header_text = ""
        self.probs = [0.0 for _ in CLASS_NAMES]
        self.pred_label = ""
        self.earliest: dict[str, QDateTime | None] = {name: None for name in CLASS_NAMES}
        self.current_dt: QDateTime | None = None
        self._show_completion_badge = False
        self.setAutoFillBackground(False)

    def set_completion_badge(self, visible: bool):
        """완료 배지 표시 설정"""
        self._show_completion_badge = bool(visible)
        self.update()

    def update_panel(self, header_text: str, probs, pred_label: str, earliest: dict, current_dt: QDateTime | None):
        """패널 내용(파일명, 판정 확률, 각 단계 시작 시각, 현재시각)을 갱신"""
        try:
            self.header_text = header_text or ""
            self.pred_label = pred_label or ""

            if probs is None:
                self.probs = [0.0 for _ in CLASS_NAMES]
            else:
                arr = list(probs)
                if len(arr) < len(CLASS_NAMES):
                    arr.extend([0.0] * (len(CLASS_NAMES) - len(arr)))
                self.probs = arr[: len(CLASS_NAMES)]

            if isinstance(earliest, dict):
                self.earliest = {name: earliest.get(name) for name in CLASS_NAMES}
            else:
                self.earliest = {name: None for name in CLASS_NAMES}

            self.current_dt = (
                current_dt if isinstance(current_dt, QDateTime) and current_dt.isValid()
                else None
            )
        except Exception:
            pass

        self.update()

    def paintEvent(self, event):
        """패널 배경, 상단 정보 텍스트, Lead Time, 클래스 박스 """
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        panel_rect = self.rect()
        painter.fillRect(panel_rect, QColor("white"))

        # 표시할 내용이 없으면 "결과 없음"
        has_header = bool(self.header_text)
        has_probs = any(self.probs)
        if not has_header and not has_probs:
            painter.setPen(QPen(Qt.gray))
            painter.drawText(panel_rect, Qt.AlignCenter, "결과 없음")
            painter.end()
            return

        # 상단 기본 정보 + 리드타임 텍스트 영역
        outer = self.OUTER_MARGIN
        line_h = self.HEADER_LINE_HEIGHT

        header_x = outer
        header_y = outer + self.HEADER_EXTRA_TOP

        title_font = QFont(self.font())
        title_font.setPointSize(11)
        title_font.setBold(True)
        painter.setFont(title_font)
        painter.setPen(QPen(Qt.black))
        painter.drawText(int(header_x), int(header_y + line_h * 0), self.header_text)

        # 리드타임 계산
        lead_font = QFont(self.font())
        lead_font.setPointSize(10)
        painter.setFont(lead_font)

        icing_lead = compute_lead_minutes(self.earliest.get("Melted"), self.earliest.get("Icing"))
        iced_lead = compute_lead_minutes(self.earliest.get("Icing"), self.earliest.get("Iced"))
        current_lead = compute_lead_minutes(self.earliest.get("Iced"), self.current_dt)

        painter.drawText(int(header_x), int(header_y + line_h * 1.2), f"- Melted~Icing Time: {icing_lead} min" if icing_lead else "- Melted~Icing Time: ")
        painter.drawText(int(header_x), int(header_y + line_h * 2.2), f"- Icing~Iced Time: {iced_lead} min" if iced_lead else "- Icing~Iced Time: ")
        painter.drawText(int(header_x), int(header_y + line_h * 3.2), f"- Iced~Last Image Time: {current_lead} min" if current_lead else "- Iced~Last Image Time: ")

        # 3개 클래스 박스 레이아웃 계산
        boxes_top_y = header_y + line_h * 4 + self.BOX_TOP_EXTRA
        side_max_w = PANEL_W_PX - 2 * outer - 2 * self.BOX_GAP
        side_max_h = PANEL_H_PX - boxes_top_y - outer + self.PANEL_BOTTOM_MARGIN

        side = int(min(side_max_w / 3, side_max_h))
        side = max(side, self.BOX_MIN_SIDE)

        x0 = outer
        x1 = x0 + side + self.BOX_GAP
        x2 = x1 + side + self.BOX_GAP
        box_x_positions = [x0, x1, x2]

        # 박스 내부 스타일 설정
        title_font_box = QFont(self.font())
        title_font_box.setPointSize(12)
        title_font_box.setBold(True)

        prob_font = QFont(self.font())
        prob_font.setPointSize(12)
        prob_font.setBold(True)

        start_font = QFont(self.font())
        start_font.setPointSize(9)

        active_fill = {"Melted": QColor("#ffadad"), "Icing": QColor("#81CBF8"), "Iced": QColor("#5a63e2")}
        inactive_fill = QColor("white")
        stroke_color = QColor("black")

        # 각 클래스(Melted, Icing, Iced) 박스 그리기
        for idx, (name, x_left) in enumerate(zip(CLASS_NAMES, box_x_positions)):
            painter.setFont(title_font_box)
            painter.setPen(stroke_color)
            painter.drawText(int(x_left), int(boxes_top_y - self.BOX_TITLE_GAP), side, line_h, Qt.AlignCenter, name)

            is_active = (name == self.pred_label)
            rect_color = active_fill.get(name, inactive_fill) if is_active else inactive_fill
            painter.fillRect(int(x_left), int(boxes_top_y), side, side, rect_color)
            painter.setPen(QPen(stroke_color))
            painter.drawRect(int(x_left), int(boxes_top_y), side, side)

            # 박스 내 확률 값 텍스트
            try:
                p_val = float(self.probs[idx]) if idx < len(self.probs) else 0.0
            except Exception:
                p_val = 0.0

            painter.setFont(prob_font)

            prob_rect_top = int(boxes_top_y + side * 0.23)
            prob_rect_h = int(side * 0.40)
            painter.drawText(int(x_left), prob_rect_top, side, prob_rect_h, Qt.AlignHCenter | Qt.AlignVCenter, f"{p_val * 100:.1f}%")

            # 박스 내 시작 시각 텍스트
            painter.setFont(start_font)
            start_str = format_mmdd_hhmm(self.earliest.get(name))
            start_rect_top = int(boxes_top_y + side * 0.55)
            start_rect_h = int(side * 0.20)
            painter.drawText(int(x_left), start_rect_top, side, start_rect_h, Qt.AlignHCenter | Qt.AlignVCenter, start_str)

        if self._show_completion_badge:
            badge_w, badge_h = 54, 24
            margin = 12
            badge_x = panel_rect.right() - badge_w - margin
            badge_y = panel_rect.top() + margin
            badge_rect = QRect(int(badge_x), int(badge_y), int(badge_w), int(badge_h))

            painter.setPen(Qt.NoPen)
            painter.fillRect(badge_rect, QColor("#1e6bd6"))

            badge_font = QFont(self.font())
            badge_font.setPointSize(10)
            badge_font.setBold(True)
            painter.setFont(badge_font)
            painter.setPen(QPen(Qt.white))
            painter.drawText(badge_rect, Qt.AlignCenter, "완료")

        painter.end()

class BacklogFeeder(QObject):
    """이미지 백로그를 천천히 하나씩 흘려 보내는 전용 worker"""
    finished = Signal()
    next_image = Signal(object)

    def __init__(self, backlog):
        super().__init__()
        self.backlog = list(backlog)
        self._stop = False

    def stop(self):
        self._stop = True

    def run(self):
        for p in self.backlog:
            if self._stop:
                break
            self.next_image.emit(p)
            time.sleep(0.05)
        self.finished.emit()

class IcingClassificationGUI(QWidget):
    """메인 GUI 위젯 클래스 (ViT 분류 기반)"""

    def __init__(self):
        super().__init__()
        self.setWindowTitle('Icing Classification GUI')
        self.resize(500, 400)
        self.settings = QSettings(str(INI_SETTINGS_PATH), QSettings.IniFormat)
        self._window_position_restored = False

        # 상태 메시지 관리
        self._status_text: str = ""
        self._status_hold_until: float = 0.0
        self._no_image_grace_until: float = 0.0
        self.last_image_seen_at: float = 0.0
        self.last_allowed_seen_at: float = 0.0

        # 텍스트 박스 ('장비명_Lot#_Process')
        self.device_info_box = QLineEdit()
        self.device_info_box.setReadOnly(True)
        self.device_info_box.setFixedWidth(180)
        self.device_info_box.setAlignment(Qt.AlignCenter)

        # 현재 Cycle 시작 Lot/Attempt 및 CSV 경로/장비 정보
        self.current_cycle_start_lot: str | None = None
        self.current_cycle_start_attempt: int | None = None
        self.current_cycle_completed: bool = False
        self.cycle_csv_path: Path | None = None
        self.current_equip: str | None = None
        self.equip_csv_path: Path | None = None
        self.last_processed_dt: QDateTime | None = None
        self._recent_cycle_candidate: dict[str, object] | None = None

        # <Cycle 상세 CSV> 헤더
        self.csv_header = ['이미지 파일명', 'Attempt', '예측 라벨', 'Melted', 'Icing', 'Iced']

        self.processed_images: set[str] = set()
        self.pending_images: deque[Path] = deque()
        self._is_processing_queue = False

        # 허용 모드/리드타임/피딩 타임 관리
        self.ALLOWED_PULLER_MODES = set(ALLOWED_PULLER_MODES)
        self.no_new_image_grace_s = 9.0
        self.last_allowed_image_info: dict[str, object] = {"equip": None, "lot": None, "attempt": None, "name": None, "dt": None}
    
        # FeedingTime 기록 트리거 1회용 플래그
        self._feeding_trigger_a_fired: bool = False
        self._feeding_trigger_b_fired: bool = False

        # 비허용 공정 진입 감지용 래치/타이머
        self.disallowed_mode_latched: bool = False
        self.disallowed_entered_at: float = 0.0

        # 연속 판정(5회) 기반 시작 시각 확정용 상태
        self._streak_label: str | None = None
        self._streak_count: int = 0
        self._streak_start_dt: QDateTime | None = None
        
        self.classifier = ViTClassifier(MODEL_NAME, CHECKPOINT_PATH, CLASS_NAMES, img_size=IMG_SIZE)

        # 채택 영역 설정의 기본값 지정
        self.crop1_x = QSpinBox(maximum=9999)
        self.crop1_y = QSpinBox(maximum=9999)
        self.crop1_w = QSpinBox(maximum=9999)
        self.crop1_h = QSpinBox(maximum=9999)
        default_roi = DEFAULT_ROI_RECT

        # 채택 영역 좌표 설정 (새 키 우선, 없으면 레거시 키 또는 기본값)
        stored_vals = [
            self._load_int_setting('crop1_x', default_roi[0], legacy_keys=['crop_x']),
            self._load_int_setting('crop1_y', default_roi[1], legacy_keys=['crop_y']),
            self._load_int_setting('crop1_w', default_roi[2], legacy_keys=['crop_w']),
            self._load_int_setting('crop1_h', default_roi[3], legacy_keys=['crop_h']),
        ]
        for s, v in zip([self.crop1_x, self.crop1_y, self.crop1_w, self.crop1_h], stored_vals):
            s.setValue(v)
            s.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
            s.setFixedWidth(66)   # 채택 영역(ROI) 스핀박스 폭

        self.crop1_enabled_cb = QCheckBox()
        enabled_val = self._load_bool_setting('crop1_enabled', True)
        self.crop1_enabled_cb.setChecked(bool(enabled_val))
        # 체크 상태에 따라 스핀박스 활성/비활성
        for s in (self.crop1_x, self.crop1_y, self.crop1_w, self.crop1_h):
            s.setEnabled(bool(enabled_val))

        self.disallowed_preview_cb = QCheckBox('')
        self.disallowed_preview_cb.setChecked(self._load_bool_setting('show_disallowed_preview', False))

        # 위젯 초기화
        self.start_button = QPushButton('시작')
        self.stop_button = QPushButton('종료')
        self.stop_button.setEnabled(False)
        self.save_opt_button = QPushButton('설정 저장')
        for btn in (self.start_button, self.stop_button, self.save_opt_button):
            btn.setFixedWidth(70)    # 시작/종료/설정 저장 버튼 너비
        self.status_label = QLabel('- 대기 중 -')
        self.preview_label = ImagePreviewLabel()
        self.panel_canvas = ClassificationPanel()
        self.auto_start_on_launch = AUTO_START_ON_LAUNCH

        # Cycle 시작 Lot/Attempt 단위 earliest 시각 관리
        self.earliest_by_cycle: dict[tuple[str, int], dict[str, QDateTime | None]] = {}

        # 레이아웃 구성
        main_hbox = QHBoxLayout(self)
        main_hbox.setContentsMargins(10, 15, 10, 10)
        main_hbox.setSizeConstraint(QLayout.SetMinimumSize)

        left_panel = QVBoxLayout()
        left_panel.addWidget(self.status_label)

        btns = QHBoxLayout()
        btns.addWidget(self.device_info_box)
        btns.addWidget(self.start_button)
        btns.addWidget(self.stop_button)
        btns.addWidget(self.save_opt_button)
        left_panel.addLayout(btns)

        crop_box = QGroupBox(' 채택 영역 설정 ')
        crop_vbox = QVBoxLayout()

        crop_hbox1 = QHBoxLayout()
        crop_hbox1.addWidget(self.crop1_enabled_cb)
        crop_hbox1.addWidget(QLabel("X:")); crop_hbox1.addWidget(self.crop1_x)
        crop_hbox1.addWidget(QLabel("Y:")); crop_hbox1.addWidget(self.crop1_y)
        crop_hbox1.addWidget(QLabel("W:")); crop_hbox1.addWidget(self.crop1_w)
        crop_hbox1.addWidget(QLabel("H:")); crop_hbox1.addWidget(self.crop1_h)
        crop_vbox.addLayout(crop_hbox1)

        crop_box.setLayout(crop_vbox)

        left_panel.addWidget(crop_box)
        left_panel.addWidget(self.panel_canvas)
        left_panel.addStretch()

        right_panel = QVBoxLayout()
        preview_header = QHBoxLayout()
        preview_header.addWidget(self.disallowed_preview_cb)
        preview_header.addStretch()
        right_panel.addLayout(preview_header)
        right_panel.addWidget(self.preview_label, alignment=Qt.AlignTop)

        main_hbox.addLayout(left_panel)
        main_hbox.addLayout(right_panel)

        # 타이머/워처
        self.tail_timer = QTimer(self)
        self.tail_timer.setInterval(500)
        self.tail_timer.timeout.connect(self._main_tick)

        self.directory_watcher = ImageDirectoryWatcher(IMG_INPUT_DIR)
        self.directory_watcher.file_created.connect(self._enqueue_new_image)

        self._backlog_thread: QThread | None = None
        self._backlog_feeder: BacklogFeeder | None = None

        # 신호 연결
        self.start_button.clicked.connect(self.start_realtime)
        self.stop_button.clicked.connect(self.stop_realtime)
        self.save_opt_button.clicked.connect(self.save_options)
        self.crop1_enabled_cb.toggled.connect(self._on_crop1_toggled)
        self.disallowed_preview_cb.toggled.connect(self.update_preview)

        # 마지막 이미지 기준으로 장비/lot/공정/attempt 및 장비 요약 CSV 로드
        self._init_device_info_from_last_image()
        self._restore_window_position()
        self.update_preview()

    def _load_int_setting(self, key: str, default: int, legacy_keys=None) -> int:
        """QSettings에서 int를 읽되, 없으면 legacy_keys 순서대로 fallback 후 default 사용"""
        if legacy_keys is None:
            legacy_keys = []
        val = self.settings.value(key, None)
        if val is None:
            for lk in legacy_keys:
                val = self.settings.value(lk, None)
                if val is not None:
                    break
        if val is None:
            return int(default)
        try:
            return int(val)
        except Exception:
            return int(default)

    def _load_bool_setting(self, key: str, default: bool) -> bool:
        """QSettings에서 bool 값을 다양한 문자열 표현까지 포함해 안전하게 로드"""
        val = self.settings.value(key, None)
        if val is None:
            return default
        if isinstance(val, bool):
            return val
        if isinstance(val, (int, float)):
            return bool(val)
        if isinstance(val, str):
            s = val.strip().lower()
            if s in ("1", "true", "yes", "y", "on"):
                return True
            if s in ("0", "false", "no", "n", "off"):
                return False
        return default

    def _set_status(self, text: str, hold_s: float = 3.0):
        """상태 라벨 업데이트 헬퍼 (깜빡임 방지)"""
        now = time.monotonic()
        if text == self._status_text:
            return
        self._status_text = text
        self.status_label.setText(text)
        if hold_s and hold_s > 0:
            self._status_hold_until = now + hold_s
        else:
            self._status_hold_until = 0.0

    @staticmethod
    def _qdatetime_to_str(qdt: QDateTime | None) -> str:
        """QDateTime -> CSV 저장용 문자열 ('yyyy-MM-dd HH:mm:ss')"""
        if qdt is None or not isinstance(qdt, QDateTime) or not qdt.isValid():
            return ""
        return qdt.toString("yyyy-MM-dd HH:mm:ss")

    @staticmethod
    def _str_to_qdatetime(s: str) -> QDateTime | None:
        """CSV 문자열 -> QDateTime (24시간제 & AM/PM 12시간제)"""
        if not s:
            return None

        s = s.strip()
        if not s:
            return None
        s_norm = re.sub(r'\s+', ' ', s)

        # 24시간제
        for fmt in ("yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm"):
            qdt = QDateTime.fromString(s_norm, fmt)
            if qdt.isValid():
                return qdt

        # AM/PM 12시간제
        for fmt in ("yyyy-MM-dd h:mm:ss AP", "yyyy-MM-dd h:mm AP"):
            qdt = QDateTime.fromString(s_norm, fmt)
            if qdt.isValid():
                return qdt

        return None

    def _restore_window_position(self):
        """이전에 저장된 창 위치(INI)를 복원"""
        if self._window_position_restored:
            return
        try:
            x_val = int(self.settings.value('main_window_pos_x', 0))
            y_val = int(self.settings.value('main_window_pos_y', 0))
        except Exception:
            x_val = y_val = 0
        self._window_position_restored = True

        if x_val or y_val:
            x_val, y_val = self._adjust_position_to_screen(x_val, y_val)
            self.move(x_val, y_val)
            return
        self._move_to_default_position()

    def _move_to_default_position(self):
        """OFFSET 값 기반으로 기본 창 위치를 계산해 이동"""
        screen = self.screen() or QGuiApplication.primaryScreen()
        if screen is None:
            return
        available = screen.availableGeometry()
        frame_geo = self.frameGeometry()
        window_width = frame_geo.width()
        window_height = frame_geo.height()
        target_x = available.x() + WINDOW_OFFSET_X
        target_y = available.y() + available.height() - WINDOW_OFFSET_Y - window_height
        target_x, target_y = self._adjust_position_to_screen(target_x, target_y, window_width, window_height)
        self.move(target_x, target_y)

    def _adjust_position_to_screen(self, x, y, window_width=None, window_height=None):
        """창이 화면 영역을 벗어나지 않도록 x, y 좌표를 보정해 반환"""
        screen = self.screen() or QGuiApplication.primaryScreen()
        if screen is None:
            return int(round(x)), int(round(y))
        available = screen.availableGeometry()
        if window_width is None or window_height is None:
            frame_geo = self.frameGeometry()
            if window_width is None:
                window_width = frame_geo.width()
            if window_height is None:
                window_height = frame_geo.height()
        min_x = available.x()
        min_y = available.y()
        max_x = max(min_x, available.x() + available.width() - window_width)
        max_y = max(min_y, available.y() + available.height() - window_height)
        clamped_x = max(min_x, min(int(round(x)), max_x))
        clamped_y = max(min_y, min(int(round(y)), max_y))
        return clamped_x, clamped_y

    def save_options(self):
        """현재 ROI 값과 창 위치를 QSettings(INI)에 저장하고 상태를 표시"""
        self.settings.setValue('crop1_x', self.crop1_x.value())
        self.settings.setValue('crop1_y', self.crop1_y.value())
        self.settings.setValue('crop1_w', self.crop1_w.value())
        self.settings.setValue('crop1_h', self.crop1_h.value())
        self.settings.setValue('crop1_enabled', bool(self.crop1_enabled_cb.isChecked()))
        self.settings.setValue('show_disallowed_preview', bool(self.disallowed_preview_cb.isChecked()))
        top_left = self.frameGeometry().topLeft()
        self.settings.setValue('main_window_pos_x', int(top_left.x()))
        self.settings.setValue('main_window_pos_y', int(top_left.y()))
        self.settings.sync()
        self._set_status("설정 저장됨.")

    def _get_current_roi(self) -> tuple[int, int, int, int] | None:
        """ROI 체크박스와 스핀박스 값으로 현재 사용 중인 ROI(또는 None)를 반환"""
        if not self.crop1_enabled_cb.isChecked():
            return None
        return (int(self.crop1_x.value()), int(self.crop1_y.value()), int(self.crop1_w.value()), int(self.crop1_h.value()))

    def _get_earliest_for(self, start_lot: str, start_attempt: int) -> dict[str, QDateTime | None]:
        """Cycle 시작 (Lot, Attempt) 조합별 earliest dict 반환"""
        key = (start_lot, int(start_attempt))
        return self.earliest_by_cycle.setdefault(key, {name: None for name in CLASS_NAMES})

    def _reset_label_streak(self):
        """연속 판정 카운터 초기화"""
        self._streak_label = None
        self._streak_count = 0
        self._streak_start_dt = None

    def _reset_feeding_state(self, keep_last_allowed: bool = False, keep_badge: bool = False):
        """피딩 타임 기록 상태 초기화"""
        if not keep_last_allowed:
            self.last_allowed_image_info = {"equip": None, "lot": None, "attempt": None, "name": None, "dt": None}

        self.last_allowed_seen_at = 0.0

        if not keep_badge:
            self.panel_canvas.set_completion_badge(False)

        self.disallowed_mode_latched = False
        self.disallowed_entered_at = 0.0
        self._feeding_trigger_a_fired = False
        self._feeding_trigger_b_fired = False

    def _should_keep_last_allowed(self) -> bool:
        """마지막 허용 이미지 정보를 유지할지 여부"""
        return (isinstance(self.last_allowed_image_info, dict)
                and isinstance(self.last_allowed_image_info.get("dt"), QDateTime)
                and self.last_allowed_image_info["dt"].isValid()
                and self.last_allowed_image_info.get("lot") is not None
                and self.last_allowed_image_info.get("attempt") is not None)

    def _start_new_cycle(self, lot_number: str, attempt_value: int, clear_recent_candidate: bool = True):
        """새 cycle 시작 시 공통 초기화 처리"""
        self.current_cycle_start_lot = lot_number
        self.current_cycle_start_attempt = attempt_value
        self.cycle_csv_path = LOT_DETAILS_DIR / f"{lot_number}_{attempt_value}.csv"
        self.current_cycle_completed = False

        self._reset_panel()
        self.processed_images.clear()
        self._reset_label_streak()
        self._reset_feeding_state(keep_last_allowed=self._should_keep_last_allowed())

        if clear_recent_candidate:
            self._recent_cycle_candidate = None

    def _set_recent_cycle_candidate(self, completed: bool, last_dt: QDateTime | None, feeding_dt: QDateTime | None):
        """최근 cycle 후보 딕셔너리 생성/갱신"""
        if (self.current_cycle_start_lot is None
            or self.current_cycle_start_attempt is None
            or not isinstance(self.cycle_csv_path, Path)):
            self._recent_cycle_candidate = None
            return
        self._recent_cycle_candidate = {
            "cycle_csv_path": self.cycle_csv_path,
            "cycle_key": (self.current_cycle_start_lot, int(self.current_cycle_start_attempt)),
            "last_dt": last_dt,
            "feeding_dt": feeding_dt,
            "completed": bool(completed),
        }

    def _update_label_streak(self, label: str, cur_dt: QDateTime | None) -> QDateTime | None:
        """동일 판정 5회 연속 시 최초 시각 반환"""
        if label != self._streak_label:
            self._streak_label = label
            self._streak_count = 1
            self._streak_start_dt = cur_dt if isinstance(cur_dt, QDateTime) and cur_dt.isValid() else None
        else:
            self._streak_count += 1
            if self._streak_start_dt is None and isinstance(cur_dt, QDateTime) and cur_dt.isValid():
                self._streak_start_dt = cur_dt

        if self._streak_count >= 5 and isinstance(self._streak_start_dt, QDateTime) and self._streak_start_dt.isValid():
            return self._streak_start_dt
        return None

    def _reset_panel(self):
        """Cycle 전환 시 패널(리드타임/파일명 등) 초기화"""
        empty_earliest = {name: None for name in CLASS_NAMES}
        self.panel_canvas.update_panel("", None, "", empty_earliest, None)
        self.panel_canvas.set_completion_badge(False)

    @staticmethod
    def _parse_cycle_filename(cycle_path: Path) -> tuple[str, int] | None:
        """<Cycle 상세 CSV> 파일명에서 (start_lot, start_attempt) 추출"""
        stem = cycle_path.stem
        if "_" not in stem:
            return None
        lot_part, attempt_part = stem.rsplit("_", 1)
        try:
            attempt_val = int(attempt_part)
        except Exception:
            return None
        return lot_part, attempt_val

    def _load_cycle_details(self, cycle_path: Path):
        """<Cycle 상세 CSV>를 로드해 starts/processed/last 정보 및 마지막 판정 결과(last_label, last_probs) 반환"""
        starts = {name: None for name in CLASS_NAMES}
        processed: set[str] = set()

        last_img_name = ""
        last_img_dt: QDateTime | None = None
        last_label = ""
        last_probs = [0.0 for _ in CLASS_NAMES]

        if not cycle_path.exists():
            return starts, processed, last_img_name, last_img_dt, last_label, last_probs

        self._reset_label_streak()
        try:
            with open(cycle_path, "r", encoding="utf-8-sig", newline="") as f:
                reader = csv.reader(f)
                header = next(reader, None) or []
                idx_map = {name: i for i, name in enumerate(header)}

                name_idx = idx_map.get("이미지 파일명", 0)
                label_idx = idx_map.get("예측 라벨", 2)
                prob_idxs = [idx_map.get(cn, None) for cn in CLASS_NAMES]

                for row in reader:
                    if not row:
                        continue
                    if name_idx >= len(row) or label_idx >= len(row):
                        continue

                    img_name = row[name_idx]
                    label = row[label_idx] or ""
                    processed.add(img_name)

                    probs = []
                    for pi in prob_idxs:
                        if pi is None or pi >= len(row):
                            probs.append(0.0)
                        else:
                            probs.append(_safe_float(row[pi]))
                    if len(probs) != len(CLASS_NAMES):
                        probs = (probs + [0.0] * len(CLASS_NAMES))[: len(CLASS_NAMES)]

                    img_dt = extract_image_datetime(IMG_INPUT_DIR / img_name)

                    # earliest(5연속) 계산
                    streak_dt = self._update_label_streak(label, img_dt)
                    if streak_dt is not None:
                        prev_start = starts.get(label)
                        if prev_start is None or streak_dt < prev_start:
                            starts[label] = streak_dt

                    # "마지막 이미지" 기준(시간이 가장 큰 row)을 last_*로 유지
                    updated_last = False
                    if isinstance(img_dt, QDateTime) and img_dt.isValid():
                        if last_img_dt is None or img_dt > last_img_dt:
                            updated_last = True
                    else:
                        if last_img_dt is None and not last_img_name:
                            updated_last = True

                    if updated_last:
                        last_img_dt = img_dt if (isinstance(img_dt, QDateTime) and img_dt.isValid()) else last_img_dt
                        last_img_name = img_name
                        last_label = label
                        last_probs = probs

        except Exception as e:
            print(f"Cycle CSV 로드 실패({cycle_path.name}): {e}")

        return starts, processed, last_img_name, last_img_dt, last_label, last_probs

    def _read_existing_equip_summary(self, equip_csv_path: Path) -> dict[tuple[str, int], dict[str, object]]:
        """<장비 요약 csv>를 읽어 FeedingTime 등 기존 요약 정보를 유지하기 위한 헬퍼"""
        existing_summary: dict[tuple[str, int], dict[str, object]] = {}
        if not equip_csv_path.exists():
            return existing_summary

        try:
            with open(equip_csv_path, "r", encoding="utf-8-sig", newline="") as f:
                reader = csv.reader(f)
                header = next(reader, None) or []
                idx_map = {name: i for i, name in enumerate(header)}

                start_lot_key = "Start_Lot" if "Start_Lot" in idx_map else "Lot"
                start_attempt_key = "Start_Attempt" if "Start_Attempt" in idx_map else "Attempt"
                end_lot_key = "End_Lot"
                end_attempt_key = "End_Attempt"

                for row in reader:
                    if not row:
                        continue

                    start_lot = _csv_get(row, idx_map, start_lot_key)
                    start_attempt = _csv_get(row, idx_map, start_attempt_key)
                    if not start_lot:
                        continue
                    try:
                        start_attempt_val = int(start_attempt)
                    except Exception:
                        start_attempt_val = 0

                    feeding_dt = self._str_to_qdatetime(_csv_get(row, idx_map, "FeedingTime"))
                    end_lot = _csv_get(row, idx_map, end_lot_key) if end_lot_key in idx_map else ""
                    end_attempt = _csv_get(row, idx_map, end_attempt_key) if end_attempt_key in idx_map else ""
                    try:
                        end_attempt_val = int(end_attempt) if end_attempt != "" else None
                    except Exception:
                        end_attempt_val = None

                    existing_summary[(start_lot, start_attempt_val)] = {
                        "feeding_dt": feeding_dt,
                        "end_lot": end_lot,
                        "end_attempt": end_attempt_val,
                    }
        except Exception as e:
            print(f"장비 요약 CSV 읽기 실패: {e}")

        return existing_summary

    def _load_equip_summary_from_csv(self):
        """<Cycle 상세 csv>를 리플레이해서 <장비#.csv> 정보를 재구성"""
        if not self.current_equip:
            return

        # 재부팅 시점에 Cycle 기반 정보를 다시 채우기 위해 상태를 초기화
        self.equip_csv_path = CSV_OUTPUT_DIR / f"{self.current_equip}.csv"
        self.earliest_by_cycle.clear()
        self.processed_images.clear()
        self._reset_label_streak()
        self._recent_cycle_candidate = None

        existing_summary = self._read_existing_equip_summary(self.equip_csv_path)

        # Cycle 단위로 리플레이한 결과를 모아 장비 요약을 재작성
        summary_rows: list[list[str]] = []
        latest_ctx: tuple[tuple[str, int], dict[str, QDateTime | None], str, QDateTime | None, set[str]] | None = None
        latest_py_dt = None

        for cycle_csv in sorted(LOT_DETAILS_DIR.glob("*.csv")):
            cycle_key = self._parse_cycle_filename(cycle_csv)
            if cycle_key is None:
                continue
            start_lot, start_attempt = cycle_key

            starts, processed, last_img_name, last_img_dt, last_label, last_probs = self._load_cycle_details(cycle_csv)
            self.earliest_by_cycle[cycle_key] = starts

            end_lot = ""
            end_attempt_val: int | None = None
            if last_img_name:
                end_info = parse_filename(last_img_name)
                end_lot = end_info.get("lot") or ""
                try:
                    end_attempt_val = int(end_info.get("attempt") or 0)
                except Exception:
                    end_attempt_val = None

            existing = existing_summary.get(cycle_key, {})
            feeding_dt = existing.get("feeding_dt")
            if not isinstance(feeding_dt, QDateTime) or not feeding_dt.isValid():
                feeding_dt = None

            end_lot = existing.get("end_lot") or end_lot
            end_attempt_val = existing.get("end_attempt") if existing.get("end_attempt") is not None else end_attempt_val

            melted_dt = starts.get("Melted")
            icing_dt = starts.get("Icing")
            iced_dt = starts.get("Iced")

            melted_icing = compute_lead_minutes(melted_dt, icing_dt)
            icing_iced = compute_lead_minutes(icing_dt, iced_dt)
            iced_feeding = compute_lead_minutes(iced_dt, feeding_dt)

            summary_rows.append([self.current_equip, start_lot, str(start_attempt), end_lot, "" if end_attempt_val is None else str(end_attempt_val),
                self._qdatetime_to_str(melted_dt), self._qdatetime_to_str(icing_dt), self._qdatetime_to_str(iced_dt), self._qdatetime_to_str(feeding_dt),
                melted_icing, icing_iced, iced_feeding, last_img_name or "", self._qdatetime_to_str(last_img_dt)])

            if last_img_dt and isinstance(last_img_dt, QDateTime) and last_img_dt.isValid():
                py_dt = _qdatetime_to_datetime(last_img_dt)
                if py_dt and (latest_py_dt is None or py_dt > latest_py_dt):
                    latest_py_dt = py_dt
                    latest_ctx = (cycle_key, starts.copy(), last_img_name, last_img_dt, processed, last_label, last_probs)

        header = ["Equip", "Start_Lot", "Start_Attempt", "End_Lot", "End_Attempt", "MeltedTime", "IcingTime", "IcedTime", "FeedingTime",
                  "MeltedToIcing(min)", "IcingToIced(min)", "IcedToFeeding(min)", "LastImageName", "LastImageTime"]

        if summary_rows:
            try:
                with open(self.equip_csv_path, "w", encoding="utf-8-sig", newline="") as f:
                    writer = csv.writer(f)
                    writer.writerow(header)
                    writer.writerows(summary_rows)
            except Exception as e:
                print(f"장비 요약 CSV 재작성 실패: {e}")

        if latest_ctx is None:
            return

        (start_lot, start_attempt), starts, last_img_name, last_dt, processed, last_label, last_probs = latest_ctx
        self.current_cycle_start_lot = start_lot
        self.current_cycle_start_attempt = start_attempt
        self.cycle_csv_path = LOT_DETAILS_DIR / f"{start_lot}_{start_attempt}.csv"
        self.last_processed_dt = last_dt
        self.processed_images = processed

        existing = existing_summary.get((start_lot, start_attempt), {})
        feeding_dt = existing.get("feeding_dt")
        self.current_cycle_completed = bool(isinstance(feeding_dt, QDateTime) and feeding_dt.isValid())
        if not isinstance(feeding_dt, QDateTime) or not feeding_dt.isValid():
            feeding_dt = None
        self._set_recent_cycle_candidate(self.current_cycle_completed, last_dt, feeding_dt)

        # device_info_box 및 패널 상단 기본 정보 복원
        header_text = ""
        if last_img_name:
            info = parse_filename(last_img_name)
            if info['equip'] and info['lot'] and info['process']:
                base_info = f"{info['equip']}_{info['lot']}_{info['process']}_{info['attempt']}"
                self.device_info_box.setText(base_info)
                header_text = f"[기본 정보]  {base_info}"

        self.panel_canvas.update_panel(header_text, last_probs, last_label, starts, last_dt)
        self.panel_canvas.set_completion_badge(self.current_cycle_completed)
        if last_img_name and isinstance(last_dt, QDateTime) and last_dt.isValid():
            li = parse_filename(last_img_name)
            self.last_allowed_image_info = {
                "equip": self.current_equip or li.get("equip"),
                "lot": li.get("lot"),
                "attempt": li.get("attempt"),
                "name": last_img_name,
                "dt": last_dt,
            }

        self._reset_label_streak()

    def _rebuild_equip_summary(self, feeding_override: dict[tuple[str, int], QDateTime | None] | None = None):
        """FeedingTime 시점에만 <Cycle 상세 csv>를 집계해 <장비 요약 csv>를 재생성"""
        if not self.current_equip:
            return

        equip_csv_path = CSV_OUTPUT_DIR / f"{self.current_equip}.csv"
        self.equip_csv_path = equip_csv_path

        # 기존 요약 정보(FeedingTime 등)를 보존하기 위해 먼저 읽어둔다
        existing_summary = self._read_existing_equip_summary(equip_csv_path)

        # 상태 보존: 실시간 판정 streak 상태는 요약 재생성에 의해 흔들리지 않도록 저장/복원
        saved_streak = (self._streak_label, self._streak_count, self._streak_start_dt)

        summary_rows: list[list[str]] = []
        for cycle_csv in sorted(LOT_DETAILS_DIR.glob("*.csv")):
            cycle_key = self._parse_cycle_filename(cycle_csv)
            if cycle_key is None:
                continue
            start_lot, start_attempt = cycle_key

            starts, _, last_img_name, last_img_dt, _, _ = self._load_cycle_details(cycle_csv)

            # End 정보
            end_lot = ""
            end_attempt_val: int | None = None
            if last_img_name:
                end_info = parse_filename(last_img_name)
                end_lot = end_info.get("lot") or ""
                try:
                    end_attempt_val = int(end_info.get("attempt") or 0)
                except Exception:
                    end_attempt_val = None

            # FeedingTime 결정: override가 있으면 우선, 없으면 기존 요약에서 유지
            existing = existing_summary.get(cycle_key, {})

            feeding_dt: QDateTime | None = None
            if feeding_override is not None and cycle_key in feeding_override:
                ov = feeding_override.get(cycle_key)
                feeding_dt = ov if (isinstance(ov, QDateTime) and ov.isValid()) else None
            else:
                ft = existing.get("feeding_dt")
                feeding_dt = ft if (isinstance(ft, QDateTime) and ft.isValid()) else None

            # end_lot/end_attempt도 가능하면 기존 요약값을 우선 유지
            end_lot = existing.get("end_lot") or end_lot
            end_attempt_val = existing.get("end_attempt") if existing.get("end_attempt") is not None else end_attempt_val

            melted_dt = starts.get("Melted")
            icing_dt = starts.get("Icing")
            iced_dt = starts.get("Iced")

            melted_icing = compute_lead_minutes(melted_dt, icing_dt)
            icing_iced = compute_lead_minutes(icing_dt, iced_dt)
            iced_feeding = compute_lead_minutes(iced_dt, feeding_dt)

            summary_rows.append([
                self.current_equip,
                start_lot, str(start_attempt),
                end_lot, "" if end_attempt_val is None else str(end_attempt_val),
                self._qdatetime_to_str(melted_dt),
                self._qdatetime_to_str(icing_dt),
                self._qdatetime_to_str(iced_dt),
                self._qdatetime_to_str(feeding_dt),
                melted_icing, icing_iced, iced_feeding,
                last_img_name or "",
                self._qdatetime_to_str(last_img_dt),
            ])

        # streak 상태 복원
        self._streak_label, self._streak_count, self._streak_start_dt = saved_streak

        if not summary_rows:
            return

        header = ["Equip", "Start_Lot", "Start_Attempt", "End_Lot", "End_Attempt", "MeltedTime", "IcingTime", "IcedTime", "FeedingTime",
                "MeltedToIcing(min)", "IcingToIced(min)", "IcedToFeeding(min)", "LastImageName", "LastImageTime"]

        try:
            with open(equip_csv_path, "w", encoding="utf-8-sig", newline="") as f:
                writer = csv.writer(f)
                writer.writerow(header)
                writer.writerows(summary_rows)
        except Exception as e:
            print(f"장비 요약 CSV 저장 실패: {e}")

    def _poll_latest_image(self):
        """FeedingTime 기록 트리거 (비허용 공정으로 '진입'한 후 9초 경과 or 마지막 이미지 유입/처리 이후 9초 경과)"""
        now = time.monotonic()

        # (A) 비허용 공정 진입 후 9초 경과 트리거
        if (self.disallowed_mode_latched
            and self.disallowed_entered_at > 0.0
            and (not self._feeding_trigger_a_fired)
            and (now - self.disallowed_entered_at) >= self.no_new_image_grace_s):
            if self._record_feeding_time(trigger="A"):
                self._feeding_trigger_a_fired = True

        # (B) 이미지 유입 중단 후 후 9초 경과 트리거
        if now < self._status_hold_until:
            return
        if now < self._no_image_grace_until:
            return
        if self.pending_images or (self._backlog_thread and self._backlog_thread.isRunning()):
            return

        last_seen_any = self.last_image_seen_at
        if last_seen_any > 0.0 and (now - last_seen_any) > self.no_new_image_grace_s:
            self.preview_label.show_placeholder(NO_IMAGE_PLACEHOLDER_TEXT)
            self._set_status("신규 이미지 없음 (폴더 감시 중)", hold_s=0.0)

            if not self._feeding_trigger_b_fired:
                if self._record_feeding_time(trigger="B"):
                    self._feeding_trigger_b_fired = True
            return

    def _is_cycle_stage_times_ready(self, starts: dict[str, QDateTime | None]) -> bool:
        """Melted/Icing/Iced 시작 시각이 모두 기록됐는지 체크"""
        for k in ("Melted", "Icing", "Iced"):
            dt = starts.get(k)
            if not isinstance(dt, QDateTime) or not dt.isValid():
                return False
        return True

    def _record_feeding_time(self, trigger: str) -> bool:
        """FeedingTime 기록"""
        info = self.last_allowed_image_info
        lot = info.get("lot") if isinstance(info, dict) else None
        attempt_val = info.get("attempt") if isinstance(info, dict) else None
        feeding_dt = info.get("dt") if isinstance(info, dict) else None
        equip = info.get("equip") if isinstance(info, dict) else None

        if lot is None or attempt_val is None:
            return False
        if not isinstance(feeding_dt, QDateTime) or not feeding_dt.isValid():
            return False

        equip_val = equip or self.current_equip
        if not equip_val:
            return False

        if self.current_cycle_start_lot is None or self.current_cycle_start_attempt is None:
            return False

        # Melted/Icing/Iced 3개가 모두 기록된 경우에만 FeedingTime 기록
        starts = self._get_earliest_for(self.current_cycle_start_lot, self.current_cycle_start_attempt)
        if not self._is_cycle_stage_times_ready(starts):
            return False

        # FeedingTime 입력 시점에만 Cycle 상세 csv를 집계해 요약을 재생성
        cycle_key = (self.current_cycle_start_lot, int(self.current_cycle_start_attempt))
        self._rebuild_equip_summary({cycle_key: feeding_dt})
        self.current_cycle_completed = True

        # 최근 cycle candidate 갱신
        if isinstance(feeding_dt, QDateTime) and feeding_dt.isValid():
            self._set_recent_cycle_candidate(True, feeding_dt, feeding_dt)

        self.panel_canvas.set_completion_badge(True)
        return True

    def _main_tick(self):
        """타이머 통합 틱: 대기 중인 이미지 처리 + '신규 이미지 없음' 상태 갱신"""
        self._drain_pending_queue()
        self._poll_latest_image()

    def _is_after_last_processed(self, img_path: Path) -> bool:
        """<Cycle 상세 csv> 기반으로 '마지막 처리된 시각(self.last_processed_dt)' 이후 이미지인지 여부 확인"""
        if self.last_processed_dt is None or not isinstance(self.last_processed_dt, QDateTime):
            return True
        if not self.last_processed_dt.isValid():
            return True

        img_dt = extract_image_datetime(img_path)
        if not isinstance(img_dt, QDateTime) or not img_dt.isValid():
            return True

        base = _qdatetime_to_datetime(self.last_processed_dt)
        cur = _qdatetime_to_datetime(img_dt)
        if base is None or cur is None:
            return True
        return cur > base

    @Slot(object)
    def _enqueue_new_image(self, path_obj):
        """watchdog에서 전달된 신규 이미지 경로를 검사 후 처리 대기 큐에 넣기"""
        if path_obj is None:
            return
        path = Path(path_obj)
        if path.suffix.lower() not in ALLOWED_IMAGE_EXTS:
            return
        if not self._is_after_last_processed(path):
            return
        if path.name in self.processed_images:
            return

        self.last_image_seen_at = time.monotonic()
        self._feeding_trigger_b_fired = False
        self.pending_images.append(path)

        if not (self._backlog_thread and self._backlog_thread.isRunning()):
            self._drain_pending_queue()

    def _drain_pending_queue(self):
        """큐에 쌓인 신규 이미지를 순차 처리"""
        if self._is_processing_queue:
            return
        if self._backlog_thread and self._backlog_thread.isRunning():
            return
        self._is_processing_queue = True
        try:
            while self.pending_images:
                path = self.pending_images.popleft()
                if not isinstance(path, Path):
                    path = Path(path)
                if path.suffix.lower() not in ALLOWED_IMAGE_EXTS:
                    continue
                if path.name in self.processed_images:
                    continue
                self.process_single_image(path)
        finally:
            self._is_processing_queue = False

    def _prepare_cycle_from_image(self, lot_number: str, attempt_value: int, cur_dt: QDateTime | None):
        """Cycle 전환 여부를 판단하고 <Cycle 상세 csv> 경로/상태를 준비"""

        cand = self._recent_cycle_candidate

        # FeedingTime 여부와 무관하게 마지막 처리 시각 대비 60분 이상이면 강제 새 cycle 시작
        if isinstance(cur_dt, QDateTime) and cur_dt.isValid():
            ref_dt = None

            if isinstance(cand, dict):
                ref_dt = cand.get("last_dt")

            if not (isinstance(ref_dt, QDateTime) and ref_dt.isValid()):
                ref_dt = self.last_processed_dt

            if isinstance(ref_dt, QDateTime) and ref_dt.isValid():
                cur_py = _qdatetime_to_datetime(cur_dt)
                ref_py = _qdatetime_to_datetime(ref_dt)

                if cur_py is not None and ref_py is not None:
                    diff_min = (cur_py - ref_py).total_seconds() / 60.0

                    # 60분 이상 "미래" 갭일 때만 새 cycle
                    if diff_min >= 60.0:
                        self._start_new_cycle(lot_number, attempt_value, clear_recent_candidate=True)
                        return

        cand_completed = bool(cand.get("completed")) if isinstance(cand, dict) else False

        if (cand_completed and isinstance(cur_dt, QDateTime) and cur_dt.isValid()
            and (self.cycle_csv_path is None or cand.get("cycle_csv_path") == self.cycle_csv_path)):
            cycle_path = cand.get("cycle_csv_path")
            cycle_key = cand.get("cycle_key")
            last_dt = cand.get("last_dt")

            if (isinstance(cycle_path, Path) and isinstance(cycle_key, tuple) and isinstance(last_dt, QDateTime) and last_dt.isValid()):
                cur_py = _qdatetime_to_datetime(cur_dt)
                last_py = _qdatetime_to_datetime(last_dt)

                diff_min = None
                if cur_py is not None and last_py is not None:
                    diff_min = (cur_py - last_py).total_seconds() / 60.0

                # last_dt와 60분 이내면 Cycle 이어붙이기(resume)
                if diff_min is not None and 0.0 <= diff_min < 60.0:
                    # 1) FeedingTime 롤백 없이 Cycle 상세 재로딩으로 이어붙이기 (요약은 다음 FeedingTime 때 재생성)
                    starts, processed, _, last_img_dt, _, _ = self._load_cycle_details(cycle_path)

                    # 2) 상태 복원 (진행중으로 전환)
                    self.current_cycle_start_lot, self.current_cycle_start_attempt = cycle_key
                    self.cycle_csv_path = cycle_path
                    self.processed_images = processed
                    self.current_cycle_completed = False
                    self.earliest_by_cycle[cycle_key] = starts

                    if isinstance(last_img_dt, QDateTime) and last_img_dt.isValid():
                        self.last_processed_dt = last_img_dt

                    # 3) resume 직후 candidate는 항상 진행중으로 갱신
                    last_dt_candidate = (
                        last_img_dt if (isinstance(last_img_dt, QDateTime) and last_img_dt.isValid())
                        else last_dt
                    )
                    self._set_recent_cycle_candidate(False, last_dt_candidate, None)

                    # UI/트리거 리셋
                    self.panel_canvas.set_completion_badge(False)
                    self._feeding_trigger_a_fired = False
                    self._feeding_trigger_b_fired = False
                    return

        # resume 조건이 아니면: 기존 로직대로 새 cycle 시작
        if self.current_cycle_completed or self.current_cycle_start_lot is None or self.current_cycle_start_attempt is None:
            self._start_new_cycle(lot_number, attempt_value, clear_recent_candidate=False)

    def _on_crop1_toggled(self, checked: bool):
        """ROI 체크박스 ↔ 스핀박스 연동 토글"""
        for s in (self.crop1_x, self.crop1_y, self.crop1_w, self.crop1_h):
            s.setEnabled(bool(checked))

        self.update_preview()

    def _handle_disallowed_image(self, img_path: Path, img_name: str, roi_rect: tuple[int, int, int, int] | None):
        """비허용 공정 이미지 처리"""
        if not self.disallowed_mode_latched:
            self.disallowed_mode_latched = True
            self.disallowed_entered_at = time.monotonic()
            self._feeding_trigger_a_fired = False

        if self.disallowed_preview_cb.isChecked():
            latest_img = safe_image_load(str(img_path), as_gray=True)
            if latest_img is not None:
                self.preview_label.show_image(latest_img, filename=img_name, roi=roi_rect)
            else:
                self.preview_label.show_placeholder(NO_IMAGE_PLACEHOLDER_TEXT)
        else:
            self.preview_label.show_placeholder(DISALLOWED_PLACEHOLDER_TEXT)
        self._set_status("지정된 Puller Mode Status가 아님.", hold_s=0.0)
        self._mark_image_processed(img_name)

    def process_single_image(self, img_path: Path):
        """단일 이미지 처리 루틴 (파일명 파싱 → Cycle 상태 갱신 → 분류 → 상세 CSV 기록 → 미리보기·패널·상태 갱신 처리)"""
        try:
            info = parse_filename(img_path.name)
            lot_number = info['lot']
            attempt_value = info['attempt']
            process_name = (info.get('process') or '').upper()
            img_name = img_path.name

            # 신규 이미지 도착 시각 기록 (허용/비허용 공정 공통)
            self.last_image_seen_at = time.monotonic()
            self._feeding_trigger_b_fired = False

            if not self.current_equip:
                self.current_equip = info['equip'] or None

            # 장비#_Lot#_Process_Attempt 기본 정보 문자열
            base_info = f"{info['equip']}_{info['lot']}_{info['process']}_{info['attempt']}"
            self.device_info_box.setText(base_info)

            if img_name in self.processed_images:
                return

            # 허용 공정 여부 확인
            roi_rect = self._get_current_roi()
            if process_name not in self.ALLOWED_PULLER_MODES:
                self._handle_disallowed_image(img_path, img_name, roi_rect)
                return

            # 허용 공정으로 돌아오면 "진입" 시각 래치 해제
            if self.disallowed_mode_latched:
                self.disallowed_mode_latched = False
                self.disallowed_entered_at = 0.0

            self.last_allowed_seen_at = time.monotonic()

            cur_dt = extract_image_datetime(img_path)
            if not (isinstance(cur_dt, QDateTime) and cur_dt.isValid()):
                cur_dt = None

            self._prepare_cycle_from_image(lot_number, attempt_value, cur_dt)
            if self.current_cycle_start_lot is None or self.current_cycle_start_attempt is None:
                return
            starts = self._get_earliest_for(self.current_cycle_start_lot, self.current_cycle_start_attempt)

            # 여기부터 신규 이미지에 대한 실제 분류 판정
            label, probs, gray_for_preview = self.classifier.predict(img_path, roi=roi_rect, return_gray_for_preview=True)
            if label is None or probs is None:
                self._set_status(f"오류: {img_name} 분류 실패")
                self._mark_image_processed(img_name)
                return

            streak_dt = self._update_label_streak(label, cur_dt)
            if streak_dt is not None:
                prev_start = starts.get(label)
                if prev_start is None or streak_dt < prev_start:
                    starts[label] = streak_dt

            row = [img_name, attempt_value, label]
            row.extend([f"{p:.4f}" for p in probs])
            self.save_csv(row)
            # 장비 요약 CSV는 FeedingTime 시점에만 재생성 (실시간 갱신은 메모리 기반)

            if cur_dt and cur_dt.isValid():
                old = _qdatetime_to_datetime(self.last_processed_dt) if self.last_processed_dt else None
                new = _qdatetime_to_datetime(cur_dt)
                if new is not None and (old is None or new > old):
                    self.last_processed_dt = cur_dt

            if isinstance(self.last_processed_dt, QDateTime) and self.last_processed_dt.isValid():
                self._set_recent_cycle_candidate(False, self.last_processed_dt, None)

            self.last_allowed_image_info = {
                "equip": self.current_equip or info.get("equip"),
                "lot": lot_number,
                "attempt": attempt_value,
                "name": img_name,
                "dt": cur_dt,
            }

            # 분류에서 로딩한 그레이 이미지를 미리보기에 그대로 사용
            if gray_for_preview is not None:
                self.preview_label.show_image(gray_for_preview, filename=img_name, roi=roi_rect)
            else:
                self.preview_label.show_placeholder(NO_IMAGE_PLACEHOLDER_TEXT)

            header_text = f"[기본 정보]  {base_info}"
            self.panel_canvas.update_panel(header_text, probs, label, starts, cur_dt)
            self._set_status(f"처리됨: {img_name} → {label}")
            self._mark_image_processed(img_name)
        except Exception as e:
            self._set_status(f"오류: {e}")

    def save_csv(self, row, max_retries=5, delay=0.2):
        """<Cycle 상세 csv>에 정보 저장"""
        if not self.cycle_csv_path:
            return False
        attempt = 0
        while attempt < max_retries:
            try:
                header_exists = self.cycle_csv_path.exists()
                with open(self.cycle_csv_path, 'a', newline='', encoding='utf-8-sig') as f:
                    writer = csv.writer(f)
                    if not header_exists:
                        writer.writerow(self.csv_header)
                    writer.writerow(row)
                return True
            except Exception:
                attempt += 1
                time.sleep(delay)
        return False

    def _mark_image_processed(self, filename: str):
        """현재 세션/Cycle에서 이미 처리한 이미지명 기록"""
        if not filename:
            return
        self.processed_images.add(filename)

    def update_preview(self):
        """이미지 미리보기 / 상부 텍스트 갱신 (최신파일 기준)"""
        try:
            cands = [p for p in IMG_INPUT_DIR.iterdir() if p.suffix.lower() in ALLOWED_IMAGE_EXTS]
            if not cands:
                self.preview_label.show_placeholder(NO_IMAGE_PLACEHOLDER_TEXT)
                return
            latest = max(cands, key=lambda p: p.stat().st_mtime)
            info = parse_filename(latest.name)
            process_name = (info.get('process') or '').upper()
            if process_name not in self.ALLOWED_PULLER_MODES and not self.disallowed_preview_cb.isChecked():
                self.preview_label.show_placeholder(DISALLOWED_PLACEHOLDER_TEXT)
                return
            img = safe_image_load(str(latest), as_gray=True)
            if img is None:
                self.preview_label.show_placeholder(NO_IMAGE_PLACEHOLDER_TEXT)
                return
            self.preview_label.show_image(img, filename=latest.name, roi=self._get_current_roi())
        except Exception:
            self.preview_label.show_placeholder(NO_IMAGE_PLACEHOLDER_TEXT)

    def _init_device_info_from_last_image(self):
        """GUI 최초 실행 시 최신 이미지명으로 공정 정보 텍스트 초기화"""
        if self.device_info_box.text():
            return
        try:
            candidates = [p for p in IMG_INPUT_DIR.iterdir() if p.suffix.lower() in ALLOWED_IMAGE_EXTS]
        except Exception:
            return
        if not candidates:
            return
        try:
            latest = max(candidates, key=lambda p: p.stat().st_mtime)
            info = parse_filename(latest.name)
            self.current_equip = info['equip'] or None
            self.device_info_box.setText(f"{info['equip']}_{info['lot']}_{info['process']}_{info['attempt']}")
            # 장비명이 결정되면 요약 CSV에서 이전 상태 복원
            self._load_equip_summary_from_csv()
        except Exception:
            return

    def start_realtime(self):
        """실시간 분류 시작 (백로그 → 라이브 테일 순)"""
        self.start_button.setEnabled(False)
        self.stop_button.setEnabled(True)
        self.pending_images.clear()
        self._is_processing_queue = False
        self.directory_watcher.start()
        self.tail_timer.start()
        self._reset_label_streak()

        keep_last = (
            isinstance(self.last_allowed_image_info, dict)
            and isinstance(self.last_allowed_image_info.get("dt"), QDateTime)
            and self.last_allowed_image_info["dt"].isValid()
            and self.last_allowed_image_info.get("lot") is not None
            and self.last_allowed_image_info.get("attempt") is not None
        )

        keep_badge = bool(self.current_cycle_completed)

        self._reset_feeding_state(keep_last_allowed=keep_last, keep_badge=keep_badge)

        if self.current_cycle_completed:
            self._feeding_trigger_a_fired = True
            self._feeding_trigger_b_fired = True

        now = time.monotonic()
        self.last_image_seen_at = now
        self._no_image_grace_until = now + 3.0

        # 백로그
        backlog: list[Path] = []
        try:
            for p in IMG_INPUT_DIR.iterdir():
                if p.suffix.lower() not in ALLOWED_IMAGE_EXTS:
                    continue
                if not self._is_after_last_processed(p):
                    continue
                if p.name in self.processed_images:
                    continue
                backlog.append(p)
        except Exception:
            backlog = []

        self._start_backlog_feeder(backlog)
        self._set_status("실시간 분류 시작")

    def stop_realtime(self):
        """실시간 분류 중지"""
        self.start_button.setEnabled(True)
        self.stop_button.setEnabled(False)
        if self.tail_timer.isActive():
            self.tail_timer.stop()
        self.directory_watcher.stop()
        self.pending_images.clear()
        self._is_processing_queue = False
        try:
            if self._backlog_feeder:
                self._backlog_feeder.stop()
            if self._backlog_thread and self._backlog_thread.isRunning():
                self._backlog_thread.quit()
                self._backlog_thread.wait(2000)
        except Exception:
            pass
        self._set_status("- 중지 -")

    def _start_backlog_feeder(self, backlog):
        """시작 시점에 남아 있는 백로그 이미지를 별도 스레드로 순차 처리"""
        if not backlog:
            self._set_status("백로그 없음. 라이브 감시 시작.", hold_s=3.0)
            return
        if self._backlog_thread and self._backlog_thread.isRunning():
            return
        self._backlog_thread = QThread()
        self._backlog_feeder = BacklogFeeder(backlog)
        self._backlog_feeder.moveToThread(self._backlog_thread)
        self._backlog_thread.started.connect(self._backlog_feeder.run)
        self._backlog_feeder.next_image.connect(self.process_single_image)
        self._backlog_feeder.finished.connect(self._on_backlog_finished)
        self._backlog_feeder.finished.connect(self._backlog_thread.quit)
        self._backlog_thread.finished.connect(self._backlog_thread.deleteLater)
        self._backlog_thread.finished.connect(lambda: setattr(self, "_backlog_thread", None))
        self._backlog_thread.destroyed.connect(lambda: setattr(self, "_backlog_thread", None))
        self._backlog_feeder.finished.connect(lambda: setattr(self, "_backlog_feeder", None))
        self._backlog_thread.finished.connect(self._drain_pending_queue)
        self._backlog_thread.start()
        self._set_status(f"백로그 처리 시작: {len(backlog)}장")

    @Slot()
    def _on_backlog_finished(self):
        self._set_status("백로그 처리 완료 → 실시간 감시 중")
        self._drain_pending_queue()

    def closeEvent(self, event):
        """메인 윈도우 종료 시 현재 설정을 .ini에 자동 저장"""
        try:
            self.stop_realtime()
            self.save_options()
        except Exception:
            pass
        finally:
            super().closeEvent(event)

def main():
    app = QApplication(sys.argv)
    gui = IcingClassificationGUI()
    gui.show()
    if gui.auto_start_on_launch:
        gui.start_realtime()
    sys.exit(app.exec())

if __name__ == '__main__':
    main()
